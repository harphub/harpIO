#' Read gridded data in various formats
#'
#' \code{read_grid} is a generic function to read gridded data from a file. A
#' transformation can optionally be applied to those data.
#'
#' @param file_name A character string with the (full) file name.
#' @param parameter The parameter to be read.
#' @param file_format The file format. Possible values include grib, netcdf, FA,
#'   hdf5... Whatever the value is, it is suposed to correspond to a function
#'   "read_XXX" that can deal with the format. If not specified, the format can
#'   often be guessed correctly from file extension or the first few bytes.
#' @param file_format_opts Options for the file format as generated by one of
#'   the options functions, e.g. \code{\link{netcdf_opts}}.
#' @param vertical_coordinate The vertical coordinate for upper air data. May be
#'   "pressure" for pressure levels, "model" for model levels or "height" for
#'   height levels.
#' @param lead_time The lead times to read from a forecast file. If set to NULL,
#'   all lead times will be read from the file.
#' @param members For ensemble data, the ensemble members to read from the file.
#'   If set to NULL all members will be read.
#' @param transformation The transformation to apply to the gridded data. Can be
#'   "none", "interpolate", "regrid" or "xsection".
#' @param transformation_opts Options for the transformation as generated by
#'   \code{\link{interpolate_opts}}, \code{\link{regrid_opts}} or
#'   \code{\link{xsection_opts}}.
#' @param show_progress Show progress when reading large amounts of data.
#' @param data_frame Logical. For compatibility with current version of
#'   harpSpatial, make sure only a geofield is returned rather than a data frame
#'   when set to FALSE.
#' @param readable_times When \code{data_frame = TRUE}, whether to convert times
#'   in unix format to a data-time format. The default is TRUE.
#' @param ... All arguments passed to the specified reader function.
#'
#' @return A geofield or (possibly) a plain  matrix.
#' @export
#'
#' @examples
#' if (requireNamespace("Rgrib2", quietly = TRUE) & requireNamespace("harpData", quietly = TRUE)) {
#'   read_grid(
#'     system.file("grib/HARMUK20171015T12Z+003.grib", package = "harpData"),
#'     parameter = "T2m"
#'   )
#'   read_grid(
#'     system.file("grib/HARMUK20171015T12Z+003.grib", package = "harpData"),
#'     parameter = "RH2m"
#'   )
#'   read_grid(
#'     system.file("grib/HARMUK20171015T12Z+003.grib", package = "harpData"),
#'     parameter = "tcc"
#'   )
#' }
read_grid <- function(
  file_name,
  parameter,
  file_format         = NULL,
  file_format_opts    = list(),
  vertical_coordinate = c("pressure", "model", "height", NA),
  lead_time           = NULL,
  members             = NULL,
  transformation      = c("none", "interpolate", "regrid", "xsection"),
  transformation_opts = list(),
  show_progress       = FALSE,
  data_frame          = FALSE,
  readable_times      = TRUE,
  spread_members      = FALSE,
  ...
) {

  if (missing(parameter)) parameter <- NULL

  if (any(is.na(vertical_coordinate))) vertical_coordinate <- as.character(vertical_coordinate)
  vertical_coordinate <- match.arg(vertical_coordinate)
  transformation      <- match.arg(transformation)
  transformation_opts <- check_opts(transformation, transformation_opts)

  file_format <- check_for_na(file_format)

  if (is.null(file_format)) {
    file_format <- guess_format(file_name)
  }

  if (length(file_format) > 1) {
    stop(
      "More than one 'file_format' passed: '", paste(file_format, collpase = "','"), "'.",
      call. = FALSE
    )
  }

  if (is.na(file_format)) {
    stop("Please provide explicit file format for '", file_name, "'.", call. = FALSE)
  }

  # Make sure default interpolate_opts are set for vfld files if none are passed
  if (file_format == "vfld" && !is.element("correct_t2m", names(transformation_opts))) {
    transformation_opts <- interpolate_opts(stations = get("station_list"))
  }

  read_func <- try(get(paste0("read_", file_format)), silent = TRUE)
  if (inherits(read_func, "try-error")) {
    stop(
      "Cannot find function 'read_", file_format, "' to read ", file_format, " files.",
      call. = FALSE
    )
  }

  members   <- unique(check_for_na(members))
  lead_time <- unique(check_for_na(lead_time))
  if (is.list(parameter) && length(parameter) == 1) {
    parameter <- parameter[[1]]
  }
  if (!inherits(parameter, "harp_parameter")) {
    parameter <- unique(check_for_na(parameter))
  }

  message ("Reading ", file_name)

  gridded_data <- read_func(
    file_name           = file_name,
    parameter           = parameter,
    lead_time           = lead_time,
    members             = members,
    vertical_coordinate = vertical_coordinate,
    transformation      = transformation,
    transformation_opts = transformation_opts,
    format_opts         = file_format_opts,
    show_progress       = show_progress
  )

  if (is.element("transformation_opts", names(attributes(gridded_data)))) {
    transformation_opts <- attr(gridded_data, "transformation_opts")
  }

  data_col <- switch(
    transformation,
    "none"     = "gridded_data",
    "regrid"   = "regridded_data",
    "xsection" = "xsection_data",
    NA
  )

  if (readable_times) {

    if (!is.null(gridded_data[["fcdate"]])) {
      gridded_data[["fcdate"]] <- unix2datetime(gridded_data[["fcdate"]])
    }
    if (!is.null(gridded_data[["validdate"]])) {
      gridded_data[["validdate"]] <- unix2datetime(gridded_data[["validdate"]])
    }

  }

  if (spread_members && is.element("members", colnames(gridded_data))) {
    gridded_data[["members"]] <- paste0(
      "fcst_mbr",
      formatC(gridded_data[["members"]], width = 3, flag = "0")
    )
    gridded_data <- tidyr::spread(gridded_data, key = "members", value = data_col)
  }

  list_cols <- which(sapply(gridded_data, typeof) == "list")
  for (df_col in list_cols) {
    if (all(sapply(gridded_data[[df_col]], meteogrid::is.geofield))) {
      class(gridded_data[[df_col]]) <- c("geolist", class(gridded_data[[df_col]]))
    }
  }

  if (any(sapply(gridded_data, function(x) inherits(x, "geolist")))) {
    class(gridded_data) <- c("harp_spatial_fcst", class(gridded_data))
  }

  if (!data_frame) {

    if (is.na(data_col)) {
      #message("For transformation = '", transformation, "' data must be returned as a data frame.")
      return(gridded_data)
    }

    if (nrow(gridded_data) == 1) {
      gridded_data <- gridded_data[[data_col]][[1]]
    } else {
      gridded_data <- gridded_data[[data_col]]
      class(gridded_data) <- union("geolist", class(gridded_data))
    }

  } else {

    attr(gridded_data, "transformation_opts") <- transformation_opts

  }

  gridded_data

}

#' @rdname read_grid
#' @export
read_grid_interpolate <- function(file_name, parameter, file_format = NULL, ...) {
  if (is.null(file_format)) file_format <- guess_format(file_name)
  if (is.na(file_format)) stop("Please provide explicit file format for ", file_name, call. = FALSE)
  reader <- get(paste0("read_", file_format, "_interpolate"))
  reader(file_name, parameter = parameter, ...)
}

# Try to guess the binary format of a gridded data file.
# @param file_name The file name
# @return A character string with the format, or NA.
guess_format <- function(file_name) {
  if (!file.exists(file_name)) stop("File not found.", call. = FALSE)

  # first we try the file extension:
  ## TODO: tar? csv, txt...?
  ## for now, we assume tar -> fatar (it's the only one we know, anyway)
  ext <- tools::file_ext(file_name)
  ff <- switch(tolower(ext),
    "grib" = ,
    "grb"  = "grib",
    "nc"   = ,
    "nc4"  = ,
    "ncf"  = "netcdf",
    "h5"   = ,
    "hdf"  = ,
    "hdf5" = "hdf5",
    "tar"  = "fatar",
    NA_character_)
  ## try reading the first few bytes of the file
  if (is.na(ff)) {
    df <- file(file_name, open="rb")
    ttt <- readBin(df, "raw", n=4 * 8)
    close(df)
    if (rawToChar(ttt[1:4]) == "GRIB") return("grib")
    if (rawToChar(ttt[1:4]) == "BUFR") return("bufr")
    if (rawToChar(ttt[2:4]) == "HDF") return("hdf5")
    ## FA files have a header of 22 8-byte integers
    ## 2 and 4 should always have the same value
    header <- readBin(ttt, "integer", size=8, n=22, endian="big")
    if (as.numeric(header[2])==16 && as.numeric(header[4])==22) return("fa")
    first_line <- try(scan(file_name, nlines = 1, quiet = TRUE))
    if (!inherits(first_line, "try-error")) {
      if (is.numeric(first_line) && length(first_line) > 1 & length(first_line) < 4) {
        return("vfld")
      }
    }
  }
  return(ff)
}

check_for_na <- function(x) {
  x <- stats::na.omit(x)
  if (length(x) < 1) {
    x <- NULL
  }
  as.vector(x)
}

check_opts <- function(trans, trans_opts) {
  if (length(trans_opts) < 1) {
    if (trans == "none") {
      trans_opts[["keep_raw_data"]] <- TRUE
      return(trans_opts)
    }
    if (trans == "interpolate") {
      message(
        "transformation_opts not passed for transformation = 'interpolate'.\n",
        "Setting to default interpolate_opts()."
      )
      return(interpolate_opts())
    }
    stop("transformation_opts must be passed for transformation = '", trans, "'.", call. = FALSE)
  }
  trans_opts
}

